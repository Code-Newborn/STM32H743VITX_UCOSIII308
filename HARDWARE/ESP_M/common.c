#include "common.h"
#include <stdarg.h>
#include "ESP8266.h"
#include "stm32h7xx.h"
#include "usart.h"

static char* itoa( int value, char* string, int radix );

/*
 * 函数名：USART2_printf
 * 描述  ：格式化输出，类似于C库中的printf，但这里没有用到C库
 * 输入  ：-USARTx 串口通道，这里只用到了串口2，即USART2
 *		     -Data   要发送到串口的内容的指针
 *			   -...    其他参数
 * 输出  ：无
 * 返回  ：无
 * 调用  ：外部调用
 *         典型应用USART2_printf( USART2, "\r\n this is a demo \r\n" );
 *            		 USART2_printf( USART2, "\r\n %d \r\n", i );
 *            		 USART2_printf( USART2, "\r\n %s \r\n", j );
 */
uint8_t buffer[ 2 ] = { 0x0d, 0x0a };
void    USART_printf( USART_TypeDef* USARTx, char* Data, ... ) {
    const char* s;
    int         d;
    char        buf[ 16 ];

    va_list ap;
    va_start( ap, Data ); /*ap指向Data的下个字符*/

    while ( *Data != 0 )  // 判断是否到达字符串结束符
    {
        if ( *Data == 0x5c )  //'\'
        {
            switch ( *++Data ) {
            case 'r':  // 回车符
                HAL_UART_Transmit( &huart2, ( uint8_t* )&buffer[ 0 ], 1, 0xFFFF );
                Data++;
                break;

            case 'n':  // 换行符
                HAL_UART_Transmit( &huart2, ( uint8_t* )&buffer[ 1 ], 1, 0xFFFF );
                Data++;
                break;

            default:
                Data++;
                break;
            }
        }

        else if ( *Data == '%' ) {  //
            switch ( *++Data ) {
            case 's':                           // 字符串
                s = va_arg( ap, const char* );  // 取出ap指向的指针，并把指针前进一个char *大小

                for ( ; *s; s++ ) {
                    HAL_UART_Transmit( &huart2, ( uint8_t* )s, 1, 0xFFFF );
                    while ( __HAL_UART_GET_FLAG( &huart2, UART_FLAG_TXE ) == RESET )
                        ;
                }

                Data++;

                break;

            case 'd':
                // 十进制
                d = va_arg( ap, int );

                itoa( d, buf, 10 );

                for ( s = buf; *s; s++ ) {
                    HAL_UART_Transmit( &huart2, ( uint8_t* )s, 1, 0xFFFF );
                    while ( __HAL_UART_GET_FLAG( &huart2, UART_FLAG_TXE ) == RESET )
                        ;
                }

                Data++;

                break;

            default:
                Data++;

                break;
            }
        }

        else {
            HAL_UART_Transmit( &huart2, ( uint8_t* )Data, 1, 0xFFFF );
            Data++;
        }

        while ( __HAL_UART_GET_FLAG( &huart2, UART_FLAG_TXE ) == RESET )
            ;
    }
}

/*
 * 函数名：itoa
 * 描述  ：将整形数据转换成字符串
 * 输入  ：-radix =10 表示10进制，其他结果为0
 *         -value 要转换的整形数
 *         -buf 转换后的字符串
 *         -radix = 10
 * 输出  ：无
 * 返回  ：无
 * 调用  ：被USART2_printf()调用
 */
static char* itoa( int value, char* string, int radix ) {
    int   i, d;
    int   flag = 0;
    char* ptr  = string;

    /* This implementation only works for decimal numbers. */
    if ( radix != 10 ) {
        *ptr = 0;
        return string;
    }

    if ( !value ) {
        *ptr++ = 0x30;
        *ptr   = 0;
        return string;
    }

    /* if this is a negative value insert the minus sign. */
    if ( value < 0 ) {
        *ptr++ = '-';

        /* Make the value positive. */
        value *= -1;
    }

    for ( i = 10000; i > 0; i /= 10 ) {
        d = value / i;

        if ( d || flag ) {
            *ptr++ = ( char )( d + 0x30 );
            value -= ( d * i );
            flag = 1;
        }
    }

    /* Null terminate the string. */
    *ptr = 0;

    return string;

} /* NCL_Itoa */
